# Threading

In C#, **multithreading** can be achieved in several ways ‚Äî ranging from low-level thread handling to high-level abstractions like `async/await` and `Task Parallel Library (TPL)`.
Here‚Äôs a breakdown of **all major approaches** (from basic to advanced):

    a) Thread t = new Thread(DoWork); t.Start();

    b) ThreadPool ThreadPool.QueueUserWorkItem(state => { Console.WriteLine("Running in thread pool thread."); });

    c) Task t = Task.Run(() => DoWork()); await t;

    d) using parallel Parallel.For(0, 5, i => { Console.WriteLine($"Iteration {i} running on thread {Task.CurrentId}"); });

    e) await Task.Run(() => LongRunningOperation()); Console.WriteLine("Main thread free for other work");

    f) BackgroundWorker worker = new BackgroundWorker(); worker.DoWork += (s, e) => Console.WriteLine("Background work running..."); worker.RunWorkerAsync();

---

### üßµ 1. **Using the `Thread` Class (Low-Level Control)**

This is the most basic and manual way to create and manage threads.

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Thread t = new Thread(DoWork);
        t.Start();

        Console.WriteLine("Main thread running...");
    }

    static void DoWork()
    {
        Console.WriteLine("Worker thread running...");
    }
}
```

**‚úÖ Pros:**

* Full control over the thread lifecycle.
* You can set priority, apartment state, etc.

**‚ùå Cons:**

* Must manage synchronization, exceptions, and completion manually.
* Harder to scale.

Excellent ‚Äî that‚Äôs a **very practical multithreading question** üëè

You‚Äôre absolutely right:
When you create multiple threads manually using

```csharp
Thread t = new Thread(DoWork);
t.Start();
```

you‚Äôll lose track of which thread is **still running**, **completed**, or **failed**, unless you explicitly manage them.

Let‚Äôs go step by step üëá

---

### Deep dive into Thread

Each `Thread` object has a few useful properties:

| Property            | Description                                                |
| ------------------- | ---------------------------------------------------------- |
| `t.ManagedThreadId` | Unique ID assigned to the thread                           |
| `t.IsAlive`         | Returns `true` if the thread is still running              |
| `t.ThreadState`     | Shows thread state (Running, Stopped, WaitSleepJoin, etc.) |

**Example:**

```csharp
using System;
using System.Threading;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        List<Thread> threads = new List<Thread>();

        for (int i = 0; i < 5; i++)
        {
            int threadNum = i; // capture variable
            Thread t = new Thread(() => DoWork(threadNum));
            threads.Add(t);
            t.Start();
        }

        // Monitor thread status
        while (true)
        {
            bool allDone = true;
            foreach (var t in threads)
            {
                Console.WriteLine($"Thread {t.ManagedThreadId} - State: {t.ThreadState}");
                if (t.IsAlive)
                    allDone = false;
            }

            if (allDone)
            {
                Console.WriteLine("‚úÖ All threads completed!");
                break;
            }

            Thread.Sleep(500); // Wait before checking again
        }
    }

    static void DoWork(int id)
    {
        Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} started job {id}");
        Thread.Sleep(1000 * (id + 1)); // Simulate variable work time
        Console.WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} finished job {id}");
    }
}
```

üß† **Explanation:**

* We keep a list of all threads.
* We periodically check their `IsAlive` or `ThreadState`.
* Once all threads finish, we exit the monitoring loop.

---

## ‚úÖ 2. **Wait for Threads to Complete (Join)**

You can also simply **wait** for each thread to finish with `.Join()`:

```csharp
foreach (var t in threads)
{
    t.Join();  // Waits for thread to finish
}
Console.WriteLine("All threads finished.");
```

This blocks the main thread until all worker threads complete.

---

## üö¶ 3. **Better Alternative ‚Üí Use ThreadPool or Task**

Manually managing threads (as above) can quickly become unmanageable if you spawn many threads.
Instead, you should use **Tasks** or the **ThreadPool**, which handle tracking and pooling automatically.

**Using `Task`:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var tasks = new Task[5];

        for (int i = 0; i < 5; i++)
        {
            int jobId = i;
            tasks[i] = Task.Run(() => DoWork(jobId));
        }

        await Task.WhenAll(tasks);  // Wait for all to complete
        Console.WriteLine("‚úÖ All tasks completed!");
    }

    static void DoWork(int id)
    {
        Console.WriteLine($"Task {Task.CurrentId} started job {id}");
        Task.Delay(1000 * (id + 1)).Wait(); // Simulate work
        Console.WriteLine($"Task {Task.CurrentId} finished job {id}");
    }
}
```

‚ú® Advantages of `Task` over `Thread`:

* You don‚Äôt manually manage thread creation/destruction.
* You can easily monitor status: `task.Status`, `task.IsCompleted`, etc.
* Easy exception handling.
* Works with `async/await`.

---

## üß© 4. **If You Must Use Threads, Track Like This**

You can maintain a dictionary of running thread states:

```csharp
Dictionary<int, bool> threadStatus = new Dictionary<int, bool>();

for (int i = 0; i < 5; i++)
{
    Thread t = new Thread(() =>
    {
        int id = Thread.CurrentThread.ManagedThreadId;
        threadStatus[id] = true;
        DoWork();
        threadStatus[id] = false;
    });

    threadStatus[t.ManagedThreadId] = true;
    t.Start();
}
```

Then you can periodically print which threads are still running (`true`).

---

## üßæ Summary

| Approach     | How to Know Thread Done                                          |
| ------------ | ---------------------------------------------------------------- |
| `Thread`     | `IsAlive` / `ThreadState` / `Join()`                             |
| `ThreadPool` | Harder to track (managed by runtime)                             |
| `Task`       | `IsCompleted`, `WhenAll()`, `ContinueWith()`                     |
| `Parallel`   | Waits automatically unless `ParallelOptions` specifies otherwise |

---

Would you like me to show a **visual dashboard-style console output** (like progress bars or status lines) that tracks which thread is running or finished dynamically in real time? It makes it easier to visualize thread progress.

---

### ‚öôÔ∏è 2. **Using `ThreadPool` (Efficient Thread Reuse)**

Uses a pool of pre-created threads managed by the .NET runtime.

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        ThreadPool.QueueUserWorkItem(state => 
        {
            Console.WriteLine("Running in thread pool thread.");
        });

        Console.WriteLine("Main thread continues...");
    }
}
```

**‚úÖ Pros:**

* Reuses threads ‚Üí faster and more memory-efficient.
* No need to manage creation or destruction.

**‚ùå Cons:**

* Limited control (cannot set name, priority, etc.).
* Best for short-lived background tasks.

---

### üß© 3. **Using the `Task` Class (Task Parallel Library - TPL)**

Introduced in .NET 4.0; the preferred modern approach.

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Task t = Task.Run(() => DoWork());
        await t;
        Console.WriteLine("Main thread continues...");
    }

    static void DoWork()
    {
        Console.WriteLine("Task is running...");
    }
}
```

**‚úÖ Pros:**

* High-level abstraction.
* Supports `async`/`await`.
* Easy exception handling and cancellation via `CancellationToken`.

**‚ùå Cons:**

* Less control over the actual thread (you don‚Äôt pick the thread).

---

### ‚ö° 4. **Using `Parallel` Class (Parallel Loops and Invokes)**

Used for data parallelism ‚Äî executing multiple iterations concurrently.

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Parallel.For(0, 5, i =>
        {
            Console.WriteLine($"Iteration {i} running on thread {Task.CurrentId}");
        });
    }
}
```

**‚úÖ Pros:**

* Simple syntax for parallel loops (`Parallel.For`, `Parallel.ForEach`).
* Automatically manages threads.

**‚ùå Cons:**

* Not suitable for asynchronous operations (good for CPU-bound work).

---

### üåê 5. **Using `async` and `await` (Asynchronous Programming Model)**

Though not technically multithreading by itself, it *enables concurrency* via non-blocking operations.

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        await Task.Run(() => LongRunningOperation());
        Console.WriteLine("Main thread free for other work");
    }

    static void LongRunningOperation()
    {
        Console.WriteLine("Doing something heavy...");
    }
}
```

**‚úÖ Pros:**

* Simplifies asynchronous code.
* Non-blocking and clean syntax.
* Works seamlessly with Tasks.

**‚ùå Cons:**

* More about concurrency (not raw threads).
* Requires understanding of synchronization context.

---

### üß† 6. **Using BackgroundWorker (Legacy but Simple)**

An older event-based model for background tasks.

```csharp
using System;
using System.ComponentModel;

class Program
{
    static void Main()
    {
        BackgroundWorker worker = new BackgroundWorker();
        worker.DoWork += (s, e) => Console.WriteLine("Background work running...");
        worker.RunWorkerAsync();
    }
}
```

**‚úÖ Pros:**

* Simple for WinForms/WPF apps.
* Built-in progress and completion events.

**‚ùå Cons:**

* Obsolete for modern async programming.
* Not suitable for server-side or scalable systems.

---

### ‚öñÔ∏è 7. **Using `Reactive Extensions (Rx.NET)`**

Used for *reactive, event-driven* asynchronous programming.

```csharp
using System;
using System.Reactive.Linq;

class Program
{
    static void Main()
    {
        var observable = Observable.Range(1, 5)
                                   .SubscribeOn(System.Reactive.Concurrency.ThreadPoolScheduler.Instance);

        observable.Subscribe(x => Console.WriteLine($"Received: {x}"));
    }
}
```

**‚úÖ Pros:**

* Great for event streams and reactive systems.
* Composable and scalable.

**‚ùå Cons:**

* Steeper learning curve.
* Overkill for simple parallel tasks.

---

### üîí BONUS: Synchronization Tools

When running multiple threads, you often need to control shared data access using:

* `lock` keyword
* `Monitor`
* `Mutex`
* `SemaphoreSlim`
* `ReaderWriterLockSlim`

---

### üßæ Summary Table

| Approach           | Level  | Best For               | Control | Recommended     |
| ------------------ | ------ | ---------------------- | ------- | --------------- |
| `Thread`           | Low    | Full manual control    | High    | ‚ùå Rarely        |
| `ThreadPool`       | Medium | Background short tasks | Low     | ‚öôÔ∏è Sometimes    |
| `Task`             | High   | General parallel work  | Medium  | ‚úÖ Yes           |
| `Parallel`         | High   | CPU-bound loops        | Medium  | ‚úÖ Yes           |
| `async/await`      | High   | Asynchronous I/O work  | Low     | ‚úÖ Yes           |
| `BackgroundWorker` | Legacy | GUI background ops     | Low     | ‚ö†Ô∏è Legacy       |
| `Rx.NET`           | High   | Reactive event streams | Medium  | ‚öôÔ∏è Advanced use |

---

Would you like me to give you **a code comparison example** where the same job runs using all these approaches side by side (to see performance and syntax differences)?
